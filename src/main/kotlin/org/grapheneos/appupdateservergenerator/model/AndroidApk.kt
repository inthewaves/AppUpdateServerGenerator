package org.grapheneos.appupdateservergenerator.model

import com.android.apksig.ApkSigner
import com.android.apksig.apk.ApkFormatException
import com.android.apksig.apk.ApkUtils
import org.grapheneos.appupdateservergenerator.apkparsing.AAPT2Invoker
import org.grapheneos.appupdateservergenerator.db.AppRelease
import org.grapheneos.appupdateservergenerator.util.digest
import java.io.File
import java.io.IOException
import java.nio.ByteBuffer
import java.util.zip.ZipFile

/**
 * Encapsulates data from the [apkFile] that was taken from the [apkFile]'s manifest and signing
 * certificate info.
 */
data class AndroidApk private constructor(
    val apkFile: File,
    val label: String,
    val packageName: PackageName,
    val versionCode: VersionCode,
    val versionName: String,
    val minSdkVersion: Int,
    /**
     * Whether the APK is marked as debuggable (`android:debuggable="true"` in its `AndroidManifest.xml`).
     *
     * It is dangerous to sign debuggable APKs with production/release keys because Android
     * platform loosens security checks for such APKs. For example, arbitrary unauthorized code
     * may be executed in the context of such an app by anybody with ADB shell access.
     *
     * @see ApkSigner.Builder.setDebuggableApkPermitted
     */
    val debuggable: Boolean,
    val verifyResult: ApkVerifyResult
) {

    fun toAppRelease(releaseTimestamp: UnixTimestamp, releaseNotes: String?) = AppRelease(
        packageName = packageName,
        versionName = versionName,
        versionCode = versionCode,
        minSdkVersion = minSdkVersion,
        releaseTimestamp = releaseTimestamp,
        apkSha256 = apkFile.digest("SHA-256").encodeToBase64String(),
        v4SigSha256 = (verifyResult as? ApkVerifyResult.V4)?.v4SignatureFile
            ?.digest("SHA-256")
            ?.encodeToBase64String(),
        releaseNotes = releaseNotes
    )

    class Builder constructor(val apkFile: File) {
        var label: String? = null
        var packageName: PackageName? = null
        var versionCode: VersionCode? = null
        var versionName: String? = null
        var minSdkVersion: Int? = null
        var debuggable: Boolean? = null
        var verifyResult: ApkVerifyResult? = null

        private val isBuildable: Boolean
            get() = label != null &&
                    packageName != null &&
                    versionCode != null &&
                    versionName != null &&
                    minSdkVersion != null &&
                    debuggable != null &&
                    verifyResult != null

        fun buildIfAllPresent(): AndroidApk? {
            return if (isBuildable) {
                AndroidApk(
                    apkFile = apkFile,
                    label = label!!,
                    packageName = packageName!!,
                    versionCode = versionCode!!,
                    versionName = versionName!!,
                    minSdkVersion = minSdkVersion!!,
                    debuggable = debuggable!!,
                    verifyResult = verifyResult!!
                )
            } else {
                null
            }
        }

        /** Generated by IDEA */
        override fun toString(): String {
            return "Builder(apkFile=$apkFile, label=$label, packageName=$packageName, versionCode=$versionCode, " +
                    "versionName=$versionName, minSdkVersion=$minSdkVersion, debuggable=$debuggable, " +
                    "verifyResult=$verifyResult)"
        }
    }

    companion object {
        val ascendingVersionCodeComparator = compareBy<AndroidApk> { it.versionCode }
        val descendingVersionCodeComparator = compareByDescending<AndroidApk> { it.versionCode }

        /**
         * Builds an [AndroidApk] instance from the given [apkFile]. The input [apkFile] will be stored as the property
         * [AndroidApk.apkFile]. The `apksig` library will be used on the APK to verify its signature.
         *
         * @throws IOException if an I/O error occurs, or the APK can't be parsed by the [aaptInvoker], or the APK
         * failed to verify
         */
        fun buildFromApkAndVerifySignature(
            apkFile: File,
            aaptInvoker: AAPT2Invoker
        ): AndroidApk {
            val builder = Builder(apkFile)
            val androidManifestBytes: ByteBuffer = ZipFile(apkFile).use { zipFile ->
                val androidManifestEntry = zipFile.getEntry("AndroidManifest.xml")
                    ?: throw IOException("unable to find AndroidManifest.xml for $apkFile")
                zipFile.getInputStream(androidManifestEntry).use { ByteBuffer.wrap(it.readBytes()) }
            }
            androidManifestBytes.rewind()
            try {
                // Use ApkUtils from the apksig library, since it handles edge cases such as missing elements.
                builder.packageName =
                    PackageName(ApkUtils.getPackageNameFromBinaryAndroidManifest(androidManifestBytes))
                androidManifestBytes.rewind()
                builder.versionCode =
                    VersionCode(ApkUtils.getLongVersionCodeFromBinaryAndroidManifest(androidManifestBytes))
                androidManifestBytes.rewind()
                builder.minSdkVersion = ApkUtils.getMinSdkVersionFromBinaryAndroidManifest(androidManifestBytes)
                androidManifestBytes.rewind()

                // This can throw ApkFormatException if there is a reference to a resource for the debuggable attribute.
                // Comment from the apksig library:
                //
                // > References to resources are not supported on purpose. The
                // > reason is that the resolved value depends on the resource
                // > configuration (e.g, MNC/MCC, locale, screen density) used
                // > at resolution time. As a result, the same APK may appear as
                // > debuggable in one situation and as non-debuggable in another
                // > situation. Such APKs may put users at risk.
                builder.debuggable = ApkUtils.getDebuggableFromBinaryAndroidManifest(androidManifestBytes)
            } catch (e: ApkFormatException) {
                throw IOException("failed to parse APK details: ${e.message}", e)
            }

            // Use AAPT2's dump badging to get the version name and label so that it can resolve resource references
            // for us.
            val (versionName, label) = aaptInvoker.getVersionNameAndLabel(apkFile)
            builder.versionName = versionName
            builder.label = label

            val verifyResult = ApkVerifyResult.verifyApk(apkFile)
            if (!verifyResult.isVerified) {
                throw IOException("APK signature verification failed with errors: ${verifyResult.result.allErrors}")
            }
            builder.verifyResult = verifyResult

            return builder.buildIfAllPresent() ?: throw IOException("failed to build: $builder")
        }
    }
}
